import {promises as fs, existsSync} from 'fs'
import {MJMLJsonObject, MJMLJsonWithChildren} from 'mjml-core'
import mjml from 'mjml'
import nodeMailjet, {Email} from 'node-mailjet'
import {URL, fileURLToPath} from 'url'

const templatesDir = new URL('./templates/', import.meta.url)

function connectToMailjet(): Email.Client {
  const apiKeyPublic = process.env.MAILJET_APIKEY_PUBLIC
  const apiKeyPrivate = process.env.MAILJET_SECRET
  if (!apiKeyPrivate || !apiKeyPublic) {
    throw new Error('Missing MAILJET_APIKEY_PUBLIC or MAILJET_SECRET')
  }
  return nodeMailjet.connect(apiKeyPublic, apiKeyPrivate)
}

function isMJMLJsonWithChildren(mjmlRoot: MJMLJsonObject): mjmlRoot is MJMLJsonWithChildren {
  return !!(mjmlRoot as MJMLJsonWithChildren).children
}

interface PassportAttributes {
  passport?: {
    hidden?: boolean
  }
}

// Drop out all nodes that are marked as hidden by Passport.
function filterHiddenPassport(mjmlRoot: MJMLJsonObject): MJMLJsonObject {
  if (!isMJMLJsonWithChildren(mjmlRoot)) {
    return mjmlRoot
  }
  const childrenNode = mjmlRoot.children
  const shownChildren = childrenNode.filter(child => {
    const attributes = child && child.attributes as PassportAttributes
    return !attributes || !attributes.passport || !attributes.passport.hidden
  })
  let hasChanges = shownChildren.length < childrenNode.length
  const updatedChildren = shownChildren.map(child => {
    const updatedChild = filterHiddenPassport(child)
    if (updatedChild !== child) {
      hasChanges = true
    }
    return updatedChild
  })
  if (!hasChanges) {
    return mjmlRoot
  }
  return {
    ...mjmlRoot,
    children: updatedChildren,
  }
}

async function readTemplateFile(template: string, filename: string): Promise<string> {
  return await fs.readFile(new URL(`./${template}/${filename}`, templatesDir), {encoding: 'utf8'})
}

async function writeTemplateFile(
  template: string, filename: string, content: string): Promise<void> {
  await fs.writeFile(new URL(`./${template}/${filename}`, templatesDir), content)
}

async function getMjml(template: string): Promise<string|MJMLJsonObject> {
  const input = await readTemplateFile(template, 'template.mjml')
  if (input.slice(0, 1) === '{') {
    return filterHiddenPassport(JSON.parse(input) as MJMLJsonObject)
  }
  return input
}

// Pattern to match mustache vars: e.g. "title={{var:foo}}" => "foo".
const mustacheVarsPattern = /(?<=[ ({]var:)\w+/g

async function updateVars(template: string, html: string): Promise<void> {
  const vars = new Set([...html.matchAll(mustacheVarsPattern)].map(match => match[0]))
  const header = '# Vars used in template.html. AUTO GENERATED by mailjet/index.ts\n'
  await writeTemplateFile(template, 'vars.txt', header + [...vars].sort().join('\n') + '\n')
}

async function send(template: string): Promise<string> {
  const recipient = process.env.RECIPIENT
  if (!recipient) {
    throw new Error('No recipient defined.')
  }
  const headers = JSON.parse(await readTemplateFile(template, 'headers.json'))
  const mailjet = connectToMailjet()
  const {html} = mjml(await getMjml(template))
  updateVars(template, html)
  const request = mailjet.post('send', {version: 'v3.1'}).request({Messages: [{
    From: {
      Email: headers.SenderEmail,
      Name: headers.SenderName,
    },
    HTMLPart: html,
    Subject: headers.Subject,
    TemplateErrorReporting: {Email: recipient},
    TemplateLanguage: true,
    TextPart: await readTemplateFile(template, 'template.txt'),
    To: [{Email: recipient}],
    TrackClicks: 'disabled',
    TrackOpens: 'disabled',
    Variables: JSON.parse(await readTemplateFile(template, 'vars-example.json')),
  }]})
  const result = await request
  return result.body + ''
}

interface TemplateDef {
  readonly mailjetTemplate: number
  readonly name: string
  readonly i18n?: {readonly [lang: string]: number}
}

async function getMailjetTemplates(): Promise<readonly TemplateDef[]> {
  const content = await fs.readFile(
    new URL('./templates/mailjet.json', import.meta.url), {encoding: 'utf8'})
  return JSON.parse(content)
}

interface TemplateDetailContent {
  Headers: Record<string, unknown>
  'Html-part': string
  MJMLContent: MJMLJsonObject
  'Text-part': string
}

async function download(template: string): Promise<void> {
  const mailjet = connectToMailjet()
  const mailjetTemplates = await getMailjetTemplates()
  const templateProps = mailjetTemplates.find(({name}) => name === template)
  if (!templateProps || !templateProps.mailjetTemplate) {
    throw new Error(`Unknown template (no data in mailjet.json): ${template}`)
  }
  const templateDir = new URL(`./${template}`, templatesDir)
  if (!existsSync(templateDir)) {
    await fs.mkdir(templateDir)
  }
  const request = mailjet.get('template', {version: 'v3'}).
    id(templateProps.mailjetTemplate + '').
    action('detailcontent').
    request()
  const result = (await request).body
  if (result.Count !== 1) {
    throw new Error(JSON.stringify(result, undefined, 2))
  }
  const detailContent = result.Data[0] as TemplateDetailContent
  const html = detailContent['Html-part']
  updateVars(template, html)
  await writeTemplateFile(
    template, 'headers.json', JSON.stringify(detailContent.Headers, undefined, 2) + '\n')
  await writeTemplateFile(
    template, 'template.mjml', JSON.stringify(detailContent.MJMLContent, undefined, 2) + '\n')
  await writeTemplateFile(template, 'template.html', html)
  await writeTemplateFile(template, 'template.txt', detailContent['Text-part'])
}

async function upload(template: string): Promise<string> {
  const mailjet = connectToMailjet()
  const mailjetTemplates = await getMailjetTemplates()
  const templateProps = mailjetTemplates.find(({name}) => name === template)
  if (!templateProps || !templateProps.mailjetTemplate) {
    throw new Error(`Unknown template (no data in mailjet.json): ${template}`)
  }
  const mjmlContent = await getMjml(template)
  const {html} = mjml(mjmlContent)
  updateVars(template, html)
  const request = mailjet.post('template', {version: 'v3'}).
    id(templateProps.mailjetTemplate + '').
    action('detailcontent').
    request({
      'Headers': JSON.parse(await readTemplateFile(template, 'headers.json')),
      'Html-part': html,
      'MJMLContent': mjmlContent,
      'Text-part': await readTemplateFile(template, 'template.txt'),
    })
  const result = await request
  return result.body + ''
}

const actionHandlers = {
  download,
  send,
  upload,
} as const

function main(action?: string, template?: string): Promise<unknown> {
  const handler = action && actionHandlers[action as keyof typeof actionHandlers]
  if (!handler) {
    throw new Error(`Action must be one of ${Object.keys(actionHandlers)}, got "${action}"`)
  }
  if (!template) {
    throw new Error('Requires a template name')
  }
  return handler(template)
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  try {
    main(...process.argv.slice(2))
  } catch (error) {
    console.log(`Usage: index.ts <action> <template-name>\n${error}`)
  }
}
