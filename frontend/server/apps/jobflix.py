"""Endpoints for the UpSkilling tool.

See http://go/jobflix:reco-design
"""

import random
import string
import typing
from typing import Any, Dict, List, Optional, Sequence, Set

import flask

from bob_emploi.frontend.api import job_pb2
from bob_emploi.frontend.api import upskilling_pb2
from bob_emploi.frontend.api import user_pb2
from bob_emploi.frontend.server import i18n
from bob_emploi.frontend.server import jobs
from bob_emploi.frontend.server import mongo
from bob_emploi.frontend.server import proto_flask
from bob_emploi.frontend.server import scoring

app = flask.Blueprint('upskilling', __name__)

_MAX_SHOWN_SECTORS = 3
_HIDDEN_SECTOR_IDS = {
    # Seasonal jobs.
    '17035', 'seasonal',
    # Low qualification jobs.
    '17039', 'no-qualif',
}


def _create_random_seed() -> str:
    return ''.join(random.choice(string.ascii_lowercase) for i in range(10))


class _InvalidState(ValueError):
    ...


class _ComputedSection(typing.NamedTuple):
    # Jobs for the section.
    jobs: List[upskilling_pb2.Job]
    # Maybe an updated ID.
    new_id: Optional[str] = None
    # Maybe an updated name.
    new_name: Optional[str] = None
    # Maybe a state param to be used at a later time.
    state: Optional[str] = None

    def __bool__(self) -> bool:
        return bool(self.jobs)


def _get_best_jobs_in_area(scoring_project: scoring.ScoringProject) -> job_pb2.BestJobsInArea:
    area_id = scoring_project.details.city.departement_id
    return jobs.get_best_jobs_in_area(
        mongo.HashableNoPiiMongoDatabase(scoring_project.database), area_id)


class _Generator:

    _num_jobs_for_first_batch = 10

    @property
    def name(self) -> str:
        """Get the default name of the sections generated by this object."""

        raise NotImplementedError

    def get_jobs(
            self, *, scoring_project: scoring.ScoringProject, allowed_job_ids: Set[str],
            previous_sections: Set[str]) -> Optional[_ComputedSection]:
        """Generate a section."""

        raise NotImplementedError

    def get_more_jobs(
            self, *, scoring_project: scoring.ScoringProject, section_id: str,
            state: str) -> upskilling_pb2.Section:
        """Generate more jobs for a given section."""

        raise NotImplementedError


class _RandomGenerator(_Generator):

    name = i18n.make_translatable_string('Des métiers au hasard')

    def get_jobs(
            self, *, allowed_job_ids: Set[str], **unused_kwargs: Any) -> Optional[_ComputedSection]:
        seed = _create_random_seed()
        randomizer = random.Random(seed)
        num_jobs = min(self._num_jobs_for_first_batch, len(allowed_job_ids))
        return _ComputedSection(
            [
                upskilling_pb2.Job(job_group=job_pb2.JobGroup(rome_id=rome_id))
                for rome_id in randomizer.sample(allowed_job_ids, num_jobs)
            ],
            state=seed)

    def get_more_jobs(
            self, *, scoring_project: scoring.ScoringProject, section_id: str,  # pylint: disable=unused-argument
            state: str) -> upskilling_pb2.Section:
        """Generate more jobs for a given section."""

        randomizer = random.Random(state)
        good_jobs = jobs.get_all_good_job_group_ids(scoring_project.database)
        num_jobs = min(30, len(good_jobs))
        return upskilling_pb2.Section(jobs=[
            upskilling_pb2.Job(job_group=job_pb2.JobGroup(rome_id=rome_id))
            for rome_id in randomizer.sample(good_jobs, num_jobs)[self._num_jobs_for_first_batch:]
        ])


class _BestJobsGenerator(_Generator):

    # This can be overriden in subclasses.
    def _create_job(self, related_job_group: job_pb2.RelatedJobGroup) -> upskilling_pb2.Job:
        return upskilling_pb2.Job(job_group=related_job_group.job_group)

    def _get_all_section_jobs(
            self, *, best_jobs: job_pb2.BestJobsInArea, scoring_project: scoring.ScoringProject) \
            -> Sequence[job_pb2.RelatedJobGroup]:
        raise NotImplementedError

    def get_jobs(
            self, *, scoring_project: scoring.ScoringProject, allowed_job_ids: Set[str],
            previous_sections: Set[str],  # pylint: disable=unused-argument
    ) -> Optional[_ComputedSection]:
        best_jobs = self._get_all_section_jobs(
            best_jobs=_get_best_jobs_in_area(scoring_project),
            scoring_project=scoring_project)
        if not best_jobs:
            return None
        best_allowed_jobs = [
            best_job
            for best_job in best_jobs
            if best_job.job_group.rome_id in allowed_job_ids
        ]
        seed = _create_random_seed()
        randomizer = random.Random(seed)
        randomizer.shuffle(best_allowed_jobs)
        return _ComputedSection(
            [
                self._create_job(best_job)
                for best_job in best_allowed_jobs[:self._num_jobs_for_first_batch]
            ],
            state=seed,
        )

    def get_more_jobs(
            self, *, scoring_project: scoring.ScoringProject, section_id: str,  # pylint: disable=unused-argument
            state: str) -> upskilling_pb2.Section:
        """Generate more jobs for a given section."""

        best_jobs = self._get_all_section_jobs(
            best_jobs=_get_best_jobs_in_area(scoring_project),
            scoring_project=scoring_project)
        allowed_job_ids = jobs.get_all_good_job_group_ids(scoring_project.database)
        best_allowed_jobs = [
            best_job
            for best_job in best_jobs
            if best_job.job_group.rome_id in allowed_job_ids
        ]
        randomizer = random.Random(state)
        randomizer.shuffle(best_allowed_jobs)
        return upskilling_pb2.Section(jobs=[
            self._create_job(best_job)
            for best_job in best_allowed_jobs[self._num_jobs_for_first_batch:]
        ])


class _BestLocalMarketScoreGenerator(_BestJobsGenerator):

    name = i18n.make_translatable_string('Des métiers avec peu de concurrence')

    def _get_all_section_jobs(
            self, *, best_jobs: job_pb2.BestJobsInArea, **unused_kwargs: Any) \
            -> Sequence[job_pb2.RelatedJobGroup]:
        return best_jobs.best_local_market_score_jobs


class _BestRelativeScoreJobsGenerator(_BestJobsGenerator):

    name = i18n.make_translatable_string('Des métiers qui recrutent bien')

    def _get_all_section_jobs(
            self, *, best_jobs: job_pb2.BestJobsInArea, **unused_kwargs: Any) \
            -> Sequence[job_pb2.RelatedJobGroup]:
        return best_jobs.best_relative_score_jobs


class _BestSalariesGenerator(_BestJobsGenerator):

    name = i18n.make_translatable_string('Des métiers avec un bon salaire')

    def _create_job(self, related_job_group: job_pb2.RelatedJobGroup) -> upskilling_pb2.Job:
        return upskilling_pb2.Job(
            job_group=related_job_group.job_group,
            shown_metric=related_job_group.local_stats.imt.junior_salary.short_text,
        )

    def _get_all_section_jobs(
            self, *, best_jobs: job_pb2.BestJobsInArea, **unused_kwargs: Any) \
            -> Sequence[job_pb2.RelatedJobGroup]:
        return best_jobs.best_salaries_jobs


class _BestSalariesLowQualifGenerator(_BestJobsGenerator):

    name = i18n.make_translatable_string(
        'Des métiers avec un bon salaire accessibles avec un Bac+2 ou moins')

    max_level: 'job_pb2.DegreeLevel.V' = job_pb2.BTS_DUT_DEUG

    def _create_job(self, related_job_group: job_pb2.RelatedJobGroup) -> upskilling_pb2.Job:
        return upskilling_pb2.Job(
            job_group=related_job_group.job_group,
            shown_metric=related_job_group.local_stats.imt.junior_salary.short_text,
        )

    def _has_low_qualif(
            self, scoring_project: scoring.ScoringProject, job: job_pb2.RelatedJobGroup) -> bool:
        job_group = jobs.get_group_proto(scoring_project.database, job.job_group.rome_id)
        if not job_group or not job_group.requirements.diplomas:
            return False
        percent_required_high_diploma = sum(
            diploma.percent_required for diploma in job_group.requirements.diplomas
            if diploma.diploma.level > self.max_level
        )
        return percent_required_high_diploma < 50

    def _get_all_section_jobs(
            self, *, best_jobs: job_pb2.BestJobsInArea, scoring_project: scoring.ScoringProject) \
            -> Sequence[job_pb2.RelatedJobGroup]:
        return [
            best_job
            for best_job in best_jobs.best_salaries_jobs
            if self._has_low_qualif(scoring_project, best_job)
        ]


class _BestSalariesNoQualifGenerator(_BestSalariesLowQualifGenerator):

    name = i18n.make_translatable_string('Des métiers avec un bon salaire accessibles sans diplôme')

    max_level = job_pb2.NO_DEGREE


class _RandomSectorGenerator(_Generator):

    name = ''

    def _get_jobs_for_sector(
            self, sector: job_pb2.SectorBestJobGroups, random_seed: str,
            allowed_job_ids: Set[str]) -> List[job_pb2.RelatedJobGroup]:
        randomizer = random.Random(random_seed)
        best_local_market_score_jobs = [
            best_job
            for best_job in sector.best_local_market_score_jobs
            if best_job.job_group.rome_id in allowed_job_ids
        ]
        randomizer.shuffle(best_local_market_score_jobs)
        return best_local_market_score_jobs

    def get_jobs(
            self, *, scoring_project: scoring.ScoringProject,
            allowed_job_ids: Set[str], previous_sections: Set[str]) \
            -> Optional[_ComputedSection]:
        previous_sector_ids = {
            section_id[len('sector-'):]
            for section_id in previous_sections
            if section_id.startswith('sector-')
        }
        if len(previous_sector_ids) >= _MAX_SHOWN_SECTORS:
            return None

        sectors = _get_best_jobs_in_area(scoring_project).sectors[:]
        random.shuffle(sectors)
        for sector in sectors:
            if sector.sector_id in previous_sector_ids or sector.sector_id in _HIDDEN_SECTOR_IDS:
                continue
            random_seed = _create_random_seed()
            best_local_market_score_jobs = self._get_jobs_for_sector(
                sector, random_seed, allowed_job_ids)
            if not best_local_market_score_jobs:
                continue
            return _ComputedSection(
                [
                    upskilling_pb2.Job(job_group=best_job.job_group)
                    for best_job in best_local_market_score_jobs[:self._num_jobs_for_first_batch]
                ],
                new_id=f'sector-{sector.sector_id}',
                new_name=sector.description,
                state=random_seed)

        # All sectors have already been selected.
        return None

    def get_more_jobs(
            self, *, scoring_project: scoring.ScoringProject, section_id: str,
            state: str) -> upskilling_pb2.Section:
        """Generate more jobs for a given section."""

        sector_id = section_id.replace('sector-', '')

        try:
            sector = next(
                s for s in _get_best_jobs_in_area(scoring_project).sectors
                if s.sector_id == sector_id
            )
        except StopIteration:
            # Cannot find sector data at all.
            return upskilling_pb2.Section()

        good_jobs = jobs.get_all_good_job_group_ids(scoring_project.database)
        sector_jobs = self._get_jobs_for_sector(sector, state, good_jobs)
        return upskilling_pb2.Section(jobs=[
            upskilling_pb2.Job(job_group=job.job_group)
            for job in sector_jobs[self._num_jobs_for_first_batch:]
        ])


_SECTION_GENERATORS: Dict[str, '_Generator'] = {
    'best-relative-local-score': _BestRelativeScoreJobsGenerator(),
    'best-local-market-score': _BestLocalMarketScoreGenerator(),
    'best-salaries': _BestSalariesGenerator(),
    'random-sector': _RandomSectorGenerator(),
    'best-salaries-no-qualifications': _BestSalariesNoQualifGenerator(),
    'best-salaries-low-qualifications': _BestSalariesLowQualifGenerator(),
    'serendipity': _RandomGenerator(),
}


_SECTION_SLOTS = [
    'best-relative-local-score',
    'best-local-market-score',
    'best-salaries',
    'random-sector',
    'best-salaries-no-qualifications',
    'best-salaries-low-qualifications',
    'random-sector',
    'serendipity',
    'random-sector',
]


@app.route('/sections', methods=['POST'])
@proto_flask.api(in_type=user_pb2.User, out_type=upskilling_pb2.Sections)
def get_sections_for_project(user_proto: user_pb2.User) -> upskilling_pb2.Sections:
    """Return all the sections to browse."""

    if not user_proto.projects:
        flask.abort(422, i18n.flask_translate("Il n'y a pas de projet à explorer."))
    project = user_proto.projects[0]
    database = mongo.get_connections_from_env().stats_db
    scoring_project = scoring.ScoringProject(project, user_proto, database)

    result = upskilling_pb2.Sections()

    good_jobs = jobs.get_all_good_job_group_ids(scoring_project.database)
    for generator_id in _SECTION_SLOTS:
        generator = _SECTION_GENERATORS[generator_id]
        computed_section = generator.get_jobs(
            scoring_project=scoring_project, allowed_job_ids=good_jobs,
            previous_sections={
                section.id
                for section in result.sections
                if section.state.startswith(f'{generator_id}:')
            })
        if not computed_section or len(computed_section.jobs) < 2:
            continue
        result.sections.add(
            id=computed_section.new_id or generator_id,
            state=f'{generator_id}:{computed_section.state or ""}',
            name=scoring_project.populate_template(scoring_project.translate_static_string(
                computed_section.new_name or generator.name)),
            jobs=computed_section.jobs,
        )

    return result


@app.route('/sections/<section_id>/jobs/<state>', methods=['POST'])
@proto_flask.api(in_type=user_pb2.User, out_type=upskilling_pb2.Section)
def get_more_jobs(
        user_proto: user_pb2.User, *, section_id: str, state: str) -> upskilling_pb2.Section:
    """Return more jobs for a given section."""

    if not user_proto.projects:
        flask.abort(422, i18n.flask_translate("Il n'y a pas de projet à explorer."))

    try:
        generator_id, section_state = state.split(':', 1)
    except ValueError:
        flask.abort(
            422,
            i18n.flask_translate("Le paramètre d'état {state} n'a pas le bon format.")
            .format(state=state))

    project = user_proto.projects[0]
    database = mongo.get_connections_from_env().stats_db
    scoring_project = scoring.ScoringProject(project, user_proto, database)

    try:
        generator = _SECTION_GENERATORS[generator_id]
    except KeyError:
        flask.abort(
            404,
            i18n.flask_translate('Générateur de section inconnu: {generator_id}')
            .format(generator_id=generator_id))

    try:
        return generator.get_more_jobs(
            scoring_project=scoring_project, section_id=section_id, state=section_state)
    except _InvalidState:
        flask.abort(
            422,
            i18n.flask_translate('Impossible de commencer à {start_from}')
            .format(start_from=section_state))
