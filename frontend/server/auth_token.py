"""Library for auth-token-related functions."""

import binascii
import datetime
import hashlib
import os
import random
import time
from typing import Optional
from urllib import parse

from bob_emploi.frontend.server import product

# This is a fake salt, not used anywhere in staging nor prod. This default
# value is used for tests and dev environment.
FAKE_SECRET_SALT = b'fake-salt-fake-salt'
SECRET_SALT = os.getenv(
    'SECRET_SALT',
    FAKE_SECRET_SALT.decode('ascii')).encode('ascii', 'ignore')
# Validity of generated salt tokens.
_SALT_VALIDITY_SECONDS = datetime.timedelta(days=2).total_seconds()
_ADMIN_AUTH_TOKEN = os.getenv('ADMIN_AUTH_TOKEN', 'fake_admin_auth_token')


def assert_valid_salt(
        salt: str, email: str, instant: Optional[int] = None,
        validity_seconds: float = _SALT_VALIDITY_SECONDS, *, role: str = '') \
        -> bool:
    """Asserts a salt is valid.

    Returns:
        True if the salt has been generated by this server less than
        _SALT_VALIDITY_SECONDS ago.
    Raises:
        ValueError if the salt has not been generated by this server.
    """

    [timestamp_str, salt_check] = salt.split('.')
    timestamp = int(timestamp_str)
    if instant:
        if timestamp > instant:
            raise ValueError("Salt's timestamp is in the future.")
        if timestamp < instant - validity_seconds:
            # Salt is too old, let's hope the client will try again with the
            # new salt.
            return False
    if salt_check != _unique_salt_check(timestamp, email + role) and (
            not role or salt_check != _unique_salt_check(timestamp, email)):
        raise ValueError("Salt's signature is invalid")
    return True


def timestamped_hash(timestamp: int, value: str) -> str:
    """Creates a cryptographic hash prefixed by a timestamp.

    This can be used either as a salt or as an auth token.
    """

    return f'{timestamp:d}.{_unique_salt_check(timestamp, value)}'


def _unique_salt_check(timestamp: int, email: str, role: str = '') -> str:
    """Hash a timestamp and email to make a salt unique to our server."""

    salter = hashlib.sha1()
    salter.update(str(timestamp).encode('ascii'))
    salter.update(str(email + role).encode('utf-8'))
    salter.update(SECRET_SALT)
    return binascii.hexlify(salter.digest()).decode('ascii')


# TODO(cyrille): Raise on all invalid tokens, and return None otherwise.
def check_token(email: str, token: str, role: str = '') -> bool:
    """Ensures a token is valid for a given role or raises a ValueError."""

    if _ADMIN_AUTH_TOKEN and token == _ADMIN_AUTH_TOKEN:
        return True
    if role == 'admin':
        if _ADMIN_AUTH_TOKEN:
            raise ValueError('An admin token is required')
        # TODO(cyrille): Also raise.
        return True
    return assert_valid_salt(token, email + role)


def check_admin_token(token: str) -> bool:
    """Ensure a token is the admin one."""

    return check_token('only-admins-allowed', token, 'admin')


def create_token(email: str, role: str = '', is_using_timestamp: bool = False) -> str:
    """Creates an auth token valid for a given email and a given role."""

    if is_using_timestamp:
        timestamp = int(time.time())
    else:
        timestamp = random.randint(0x10000, 0x1000000)

    return timestamped_hash(timestamp, email + role)


def create_logged_url(user_id: str, path: str = '') -> str:
    """Returns a route with given path and necessary query parameters for authentication."""

    params = parse.urlencode({
        'authToken': create_token(user_id, role='auth', is_using_timestamp=True),
        'userId': user_id,
    })
    return f'{parse.urljoin(product.bob.base_url, path)}?{params}'
