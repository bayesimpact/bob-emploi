#!/usr/bin/env python3
"""
Script to deploy a Bob release, both server and client.

The canonical place for our releases are the Docker Images in Docker Hub.
They are generated by CircleCI in an untainted way.

The server gets released by creating a new deployment on Amazon Web Service's
(AWS) ECS (EC2 Container Service), and waiting for new containers to be
spawned and old containers to be stopped.

The client gets released by deploying static files on OVH storage.

Environment variables required:
- GITHUB_TOKEN: GitHub credentials to check CI status, update the release and
  the prod branch.
- OS_PASSWORD, OS_USERNAME, etc: OpenStack credentials to push client app to OVH server.
- SLACK_INTEGRATION_URL: Webhook to report deploy status to Slack.

AWS CLI must be installed, and configured for a user with the bob-emploi-deploy policy:
https://console.aws.amazon.com/iam/home?region=us-east-1#/policies/arn:aws:iam::951168128976:policy/bob-emploi-deploy$serviceLevelSummary
That policy must be kept in sync with the actual actions used in this file.

Optional:
- DRY_RUN: do not actually deploy.

Usage:
python frontend/release/deploy.py $CIRCLE_TAG
"""

import argparse
import contextlib
import datetime
import glob
import json
import logging
import os
from os import path
import re
import subprocess
import sys
import tempfile
import tarfile
import typing
from typing import Iterator, Optional, Sequence

import requests

# Making sure those are actually installed, but we don't use them directly
# pylint: disable=unused-import
import awscli
import keystoneclient
import swiftclient
# pylint: enable=unused-import

if typing.TYPE_CHECKING:
    class _ParsedArgs(typing.Protocol):
        tag: str
        dry_run: bool
        github_token: str
        github_write_origin: str
        slack_url: str

    class _Hub(typing.Protocol):

        def __call__(self, *args: str) -> str:
            ...

_IS_CI = bool(os.getenv('CI'))
_DOCKER_TAG_PREFIX = 'tag-'
_DOCKER_SERVER_REPO = 'bayesimpact/bob-emploi-frontend-server'
_DOCKER_CLIENT_REPO = 'bayesimpact/bob-emploi-frontend'
# Our OpenStack container, see
# https://www.ovh.com/manager/cloud/index.html#/iaas/pci/project/7b9ade05d5f84f719adc2cbc76c07eec/storage
_OPEN_STACK_CONTAINER = 'PE Static Assets'
# Our fallback s3 bucket, see
# https://s3.console.aws.amazon.com/s3/buckets/bob-emploi-client/?region=eu-west-3&tab=overview
_S3_BUCKET = 'bob-emploi-client'
_TAG_STACK_PARAMETER = 'DockerTag'

_FORBIDDEN_CHARS = re.compile(r'[^-a-zA-Z0-9]+')


@contextlib.contextmanager
def pushd(new_dir: str) -> Iterator[None]:
    """Context manager for pushd/popd."""

    old_dir = os.getcwd()
    os.chdir(new_dir)
    try:
        yield
    finally:
        os.chdir(old_dir)


def _check_open_stack() -> None:
    description = '''\
        * Go to https://www.ovh.com/manager/cloud and select: Servers -> OpenStack
        * Create a user if you do not have any, and copy the password
        * Click on the little wrench and select 'Downloading an Openstack configuration file'
        * Select 'GRA - Gravelines'
        * Source this file to export the OpenStack environment variables, \
it will ask for your password.'''
    if not os.getenv('OS_PASSWORD'):
        raise ValueError(f'Set up OpenStack credentials first.\n{description}')
    try:
        subprocess.check_output(('swift', 'list'), text=True)
    except subprocess.CalledProcessError as error:
        raise ValueError(f'OpenStack credentials are incorrect.\n{description}') from error


def _check_args(args: '_ParsedArgs') -> None:
    if _IS_CI and not args.github_token:
        raise ValueError('''Setup GITHUB_TOKEN env variable to get `hub` to work.
            * Use one from the bob-emploi GitHub user.
            * Create one on https://github.com/settings/tokens''')
    if args.github_token:
        args.github_write_origin = \
            f'https://{args.github_token}@github.com/bayesimpact/bob-emploi-internal.git'
    if args.dry_run:
        logging.warning('DRY RUN: will not actually modify anything.')
    if not args.tag:
        raise ValueError('No tag provided')
    if not subprocess.check_output(('git', 'tag', '-l', args.tag), text=True).strip():
        raise ValueError(f'The tag {args.tag} does not exist locally.')
    if not args.slack_url:
        raise ValueError('''Set up the Slack integration first.
            * Find private URL for Slack Integration at https://bayesimpact.slack.com/apps/A0F7XDUAZ-incoming-webhooks
            * Add this URL in your bashrc as SLACK_INTEGRATION_URL env var''')


def _docker_tag_exists(image: str, tag: str) -> bool:
    response = requests.get(f'https://index.docker.io/v1/repositories/{image}/tags/{tag}')
    return response.status_code < 400


def _check_docker_images(docker_tag: str) -> None:
    logging.info('Checking that the Docker images exists…')
    if not _docker_tag_exists(_DOCKER_CLIENT_REPO, docker_tag) or \
            not _docker_tag_exists(_DOCKER_SERVER_REPO, docker_tag):
        raise ValueError(f'The tag {docker_tag} is not present in Docker Registry.')


def _get_previous_tag(region: str, stack_name: str) -> str:
    fr_stack_description = json.loads(subprocess.check_output((
        'aws', 'cloudformation', 'describe-stacks',
        '--region', region, '--stack-name', stack_name)))
    return typing.cast(str, next(
        param['ParameterValue'] for param in fr_stack_description['Stacks'][0]['Parameters']
        if param['ParameterKey'] == _TAG_STACK_PARAMETER))


def _make_release_notes(tag: str, hub: '_Hub') -> str:
    try:
        release_notes = hub('release', 'show', tag)
    except subprocess.CalledProcessError as error:
        raise ValueError('No release notes found.') from error

    logging.info('''Release notes are:
-------------------------------------------------------------------------------
%s
-------------------------------------------------------------------------------''', release_notes)
    release_notes = '\n'.join(
        line
        for line in release_notes.split('\n')
        if not line.startswith('#'))
    if not release_notes.strip():
        raise ValueError('''Canceling deployment due to empty release notes. This is not expected, \
the workflow step ask-for-manual-approval should have required the release notes.''')
    return release_notes + f'\n\nDeployed on {datetime.datetime.now()}'


def deploy_stack_servers(docker_tag: str, dry_run: bool) -> None:
    """Deploy the new server version on Cloudformation."""

    logging.info('Deploying the new server version…')
    change_set_name = _FORBIDDEN_CHARS.sub('-', f'deploy-{docker_tag}')
    cmd: tuple[str, ...] = (
        sys.executable, path.join(path.dirname(__file__), 'cloudformation', 'deploy.py'),
    )
    if not dry_run:
        cmd += ('--no-dry-run',)
    cmd += (
        '--change-set-name', change_set_name, 'parameter', f'{_TAG_STACK_PARAMETER}={docker_tag}')
    subprocess.run(cmd, check=True)


def strip_member_components(archive: tarfile.TarFile, component: int) -> Iterator[tarfile.TarInfo]:
    """Return members of the archive with stripped prefix (same as --strip-components)."""
    for member in archive.getmembers():
        try:
            member.path = member.path.split('/', component)[component]
            yield member
        except IndexError:
            pass


def _extract_and_upload(archive: tarfile.TarFile, dry_run: bool) -> None:
    archive.extractall(members=strip_member_components(archive, 1))
    # TODO(cyrille): Also drop Showcase demos.
    subprocess.run('rm -r *Demo', shell=True, check=True)
    all_files = glob.glob('*', recursive=True)
    if dry_run:
        logging.info('Client assets:\n%s', '\n'.join(all_files))
    else:
        subprocess.run(
            ('swift', 'upload', _OPEN_STACK_CONTAINER, '--skip-identical', *all_files), check=True)
        subprocess.run(
            ('aws', 's3', 'cp', os.getcwd(), f's3://{_S3_BUCKET}/', '--recursive'), check=True)


def deploy_client(client_image: str, dry_run: bool) -> None:
    """Deploy client assets to OVH and S3."""

    logging.info('Downloading the client Docker Image…')
    subprocess.run(('docker', 'pull', client_image), check=True)

    logging.info('Extracting the archive from the Docker Image…')
    with tempfile.NamedTemporaryFile(delete=False, suffix='.tar') as archive_file:
        client_container = subprocess.check_output(
            ('docker', 'create', client_image), text=True).strip()
        subprocess.run(
            ('docker', 'cp', f'{client_container}:/usr/share/bob-emploi/html', '-'),
            check=True, stdout=archive_file)
        logging.info('Client assets archive saved to %s', archive_file.name)
        subprocess.run(('docker', 'rm', client_container), check=True)

    logging.info('Extracting files from the archive…')
    with tempfile.TemporaryDirectory() as tempdir:
        with tarfile.open(archive_file.name) as archive:
            with pushd(tempdir):
                _extract_and_upload(archive, dry_run)


def log_to_github(hub: '_Hub', tag: str, *, release_notes: str, origin: str) -> None:
    """Logging the deployment on GitHub."""

    logging.info('Logging the deployment on GitHub…')
    hub('release', 'edit', '--draft=false', '-m', release_notes, tag)
    subprocess.run(('git', 'push', '-f', origin, f'{tag}~0:prod'), check=True)


def notify_slack(
        slack_url: str, dry_run: bool, *,
        tag: str, release_notes: str, previous_release: str) -> None:
    """Send a slack notification."""

    rollback = f'python frontend/release/deploy.py {previous_release} --no-add-tag-prefix'
    slack_message = {
        'attachments': [{'fields': [{
            'title': 'Release Notes',
            'value': release_notes,
        }]}],
        'text': f'A new version of Bob has been deployed ({tag}).\nTo rollback run: `{rollback}`',
    }
    if dry_run:
        logging.info(
            'Would send the following message to Slack:\n%s', json.dumps(slack_message, indent=2))
    else:
        requests.post(slack_url, json=slack_message)


def main(string_args: Optional[Sequence[str]] = None) -> None:
    """Run the script."""

    parser = argparse.ArgumentParser(description='Deploy a Bob release.')
    parser.add_argument('tag', help='''The git tag to be deployed''')
    parser.add_argument('--no-add-tag-prefix', action='store_true')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument(
        '--slack-url', default=os.getenv('SLACK_INTEGRATION_URL'),
        help='''A webhook to send a deployment report to slack.''')
    parser.add_argument(
        '--github-token', default=os.getenv('GITHUB_TOKEN'),
        help='''An authentication token with write permissions on the repo''')
    parser.add_argument(
        '--github-write-origin', default='origin',
        help='''A git remote name for the Github repository.''')

    args: '_ParsedArgs' = parser.parse_args(string_args)
    _check_args(args)

    _check_open_stack()

    if args.no_add_tag_prefix:
        docker_tag = args.tag
    else:
        docker_tag = f'{_DOCKER_TAG_PREFIX}{args.tag}'
    _check_docker_images(docker_tag)

    hub_env: Optional[dict[str, str]] = None
    if args.github_token:
        hub_env = os.environ | {'GITHUB_TOKEN': args.github_token}

    def _hub(*cmd: str) -> str:
        return subprocess.check_output(('hub', *cmd), text=True, env=hub_env).strip()

    # TODO(cyrille): Use values from stack_deployments.json.
    previous_tag = _get_previous_tag('eu-west-3', 'bob-fr')
    deploy_stack_servers(docker_tag, args.dry_run)
    deploy_client(f'{_DOCKER_CLIENT_REPO}:{docker_tag}', args.dry_run)

    # Release was successful, let's tell it to the world.

    release_notes = _make_release_notes(args.tag, _hub)
    if not args.dry_run:
        log_to_github(_hub, args.tag, release_notes=release_notes, origin=args.github_write_origin)

    notify_slack(
        args.slack_url, args.dry_run,
        release_notes=release_notes, tag=args.tag,
        previous_release=previous_tag)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
