"""Importer for local market information for a given area to MongoDB."""

import locale
import math
import os
import re
import typing
from typing import Any, Callable, Dict, List

import pandas

from bob_emploi.frontend.api import job_pb2
from bob_emploi.data_analysis.lib import cleaned_data
from bob_emploi.data_analysis.lib import mongo

locale.setlocale(locale.LC_ALL, 'fr_FR.UTF-8')

# Sector names are of the form 'Métiers du sport et autour du sport'.
# This regex allows to split this to capture only 'du sport'.
_SECTOR_TRIMMING_REGEX = re.compile(r'Métiers | et |, |\(')
# Meaningful IDs derived by hand from rome_item_arborescence (v344).
_SECTOR_IDS = {
    '17003': 'environment',
    '17024': 'defense',
    '17025': 'heritage',
    '17026': 'economy-intelligence',
    '17027': 'research',
    '17028': 'sea',
    '17029': 'aeronautics',
    '17030': 'security',
    '17031': 'multimedia',
    '17032': 'humanitarian',
    '17033': 'nuclear',
    '17034': 'children',
    '17035': 'seasonal',
    '17036': 'personal-services',
    '17037': 'sport',
    '17038': 'engineering',
    '17039': 'no-qualif',
}
# TODO(cyrille): Consider using this for all sectors.
_SECTOR_RENAMING = {
    'defense': 'dans le secteur de la défense et de la sécurité publique',
    'security': 'dans le secteur de la sécurité publique et privée',
    'children': "dans le secteur de l'enfance",
    'seasonal': 'saisonniers, de vacances',
    'no-training': 'accessibles sans diplôme et sans expérience',
}


def csv2dicts(*, imt_folder: str, pcs_rome_crosswalk: str, rome_item_arborescence: str) \
        -> List[Dict[str, Any]]:
    """Import departement level diagnosis data in MongoDB.

    Args:
        imt_folder: path to a local folder containing IMT csv files. Can be
            generated by `make imt`.
    """

    market_score_csv = os.path.join(imt_folder, 'market_score.csv')
    market_scores = _get_market_scores(market_score_csv)

    # Best local market score jobs.
    best_local_scores = market_scores[market_scores.area_type == 'D'].dropna()\
        .sort_values('yearlyAvgOffersPer10Candidates', ascending=False)\
        .groupby('area_id').apply(_create_market_score_job_group_list)
    areas = best_local_scores.rename('bestLocalMarketScoreJobs')\
        .rename_axis('_id')\
        .reset_index().set_index('_id', drop=False)

    # Best relative score jobs.
    national_scores = market_scores[market_scores.area_type == 'F']\
        .groupby('rome_id').first().yearlyAvgOffersPer10Candidates.dropna()
    market_scores['national_score'] = market_scores.rome_id.map(national_scores)
    market_scores['local_relative_score'] = market_scores.yearlyAvgOffersPer10Candidates.\
        div(market_scores.national_score)
    best_local_relative_scores = market_scores[market_scores.area_type == 'D']\
        .dropna(subset=['local_relative_score'])\
        .sort_values('local_relative_score', ascending=False)\
        .groupby('area_id').apply(_create_market_score_job_group_list)
    areas['bestRelativeScoreJobs'] = best_local_relative_scores

    # Best salaries jobs.
    market_salaries_csv = os.path.join(imt_folder, 'salaries.csv')
    market_salaries = cleaned_data.imt_salaries(
        filename=market_salaries_csv,
        pcs_crosswalk_filename=pcs_rome_crosswalk)
    best_salaries_jobs = market_salaries.reset_index()\
        .dropna(subset=['junior_min_salary'])\
        .sort_values('junior_min_salary', ascending=False)\
        .groupby('departement_id').apply(_create_salaries_job_group_list)
    areas['bestSalariesJobs'] = best_salaries_jobs

    # Sectors.
    sector_scores = market_scores[
        (market_scores.area_type == 'D') & (market_scores.yearlyAvgOffersPer10Candidates >= 6)
    ].dropna().merge(_get_rome_sectors(rome_item_arborescence), on='rome_id')\
        .sort_values('yearlyAvgOffersPer10Candidates', ascending=False)\
        .dropna()\
        .groupby(['area_id', 'sector_id', 'sector_name'])\
        .apply(_create_market_score_job_group_list)\
        .rename('bestLocalMarketScoreJobs', axis=1)\
        .reset_index()
    sector_scores['sectorId'] = sector_scores.sector_id.map(_SECTOR_IDS)
    sector_scores['description'] = sector_scores.apply(_beautify_sector_name, axis=1)
    sector_scores.drop(columns=['sector_name', 'sector_id'], inplace=True)
    sectors_by_area = sector_scores.groupby('area_id').apply(
        lambda df: df.drop(columns=['area_id']).to_dict('records'))
    areas['sectors'] = sectors_by_area

    return [
        _drop_nan_properties(record)
        for record in typing.cast(List[Dict[str, Any]], areas.to_dict(orient='records'))
    ]


def _get_market_scores(market_score_csv: str) -> pandas.DataFrame:
    market_stats = pandas.read_csv(market_score_csv, dtype={'AREA_CODE': 'str'})

    # Converting to int from np.int32 so that json serialization does not choke.
    market_stats['yearlyAvgOffersPer10Candidates'] = pandas.to_numeric(market_stats.TENSION_RATIO)
    market_stats.loc[
        market_stats.yearlyAvgOffersPer10Candidates == 0, 'yearlyAvgOffersPer10Candidates'] = -1
    market_stats['area_id'] = market_stats.AREA_CODE
    market_stats['area_type'] = market_stats.AREA_TYPE_CODE
    market_stats['rome_id'] = market_stats.ROME_PROFESSION_CARD_CODE
    return market_stats[['area_type', 'area_id', 'rome_id', 'yearlyAvgOffersPer10Candidates']]


def _create_market_score_job_group_list(job_groups: pandas.DataFrame) -> List[Dict[str, Any]]:
    good_hiring_job_groups = job_groups[job_groups.yearlyAvgOffersPer10Candidates >= 7]
    return _create_job_group_list(good_hiring_job_groups, lambda job_group: {'imt': {
        'yearlyAvgOffersPer10Candidates': job_group.yearlyAvgOffersPer10Candidates,
    }})


def _create_salaries_job_group_list(job_groups: pandas.DataFrame) -> List[Dict[str, Any]]:
    good_pay_job_groups = job_groups[job_groups.junior_min_salary >= 2200]
    return _create_job_group_list(good_pay_job_groups, lambda job_group: {'imt': {
        'juniorSalary': _get_single_salary_detail(
            job_group.junior_min_salary,
            job_group.junior_max_salary),
        'seniorSalary': _get_single_salary_detail(
            job_group.senior_min_salary,
            job_group.senior_max_salary),
    }})


def _create_job_group_list(
        job_groups: pandas.DataFrame,
        get_local_stats: Callable[[Any], Dict[str, Any]]) -> List[Dict[str, Any]]:
    return [
        {
            'jobGroup': {'romeId': job_group.rome_id},
            'localStats': get_local_stats(job_group),
        }
        for job_group in job_groups.head(50).itertuples(index=False)
    ]


def _beautify_sector_name(sector: pandas.Series) -> str:
    qualification = _SECTOR_TRIMMING_REGEX.split(sector.at['sector_name'])[1]
    qualification = _SECTOR_RENAMING.get(
        sector.at['sectorId'], f' dans le secteur {qualification}')
    return f'Des métiers {qualification} %inDepartement'


def _isnan(value: Any) -> bool:
    """Check whether a Python value is numpy's NaN."""

    return isinstance(value, float) and math.isnan(value)


def _get_single_salary_detail(min_salary: float, max_salary: float) -> Dict[str, Any]:
    if _isnan(min_salary) and _isnan(max_salary):
        return {}
    from_salary = locale.format_string('%d', min_salary, grouping=True)
    to_salary = locale.format_string('%d', max_salary, grouping=True)
    short_text = f'De {from_salary}\xa0€ à {to_salary}\xa0€'
    return {
        'unit': job_pb2.SalaryUnit.Name(job_pb2.MONTHLY_GROSS_SALARY),
        'shortText': short_text,
        'minSalary': min_salary,
        'maxSalary': max_salary
    }


def _drop_nan_properties(properties: Dict[str, Any]) -> Dict[str, Any]:
    nan_properties = {
        prop for prop, value in properties.items()
        if _isnan(value)
    }
    for prop in nan_properties:
        del properties[prop]
    return properties


def _get_rome_sectors(rome_item_arborescence: str) -> pandas.DataFrame:
    sector_jobs = pandas.read_csv(rome_item_arborescence, dtype='str')[[
        'code_ogr', 'code_pere', 'code_noeud', 'libelle_item_arbo',
    ]]
    sectors = sector_jobs[sector_jobs.code_pere == 'Racine AR'].set_index('code_noeud')
    sector_jobs = sector_jobs[sector_jobs.code_pere.isin(sectors.index)][[
        'code_pere', 'code_noeud']]
    sector_jobs = sector_jobs.join(sectors, on='code_pere', rsuffix='_sector')
    return sector_jobs.rename(columns={
        'code_noeud': 'rome_id',
        'code_ogr': 'sector_id',
        'libelle_item_arbo': 'sector_name',
    })[['rome_id', 'sector_id', 'sector_name']]


if __name__ == '__main__':
    mongo.importer_main(csv2dicts, 'best_jobs_in_area')
